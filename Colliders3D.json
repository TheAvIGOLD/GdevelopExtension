{
  "author": "",
  "category": "General",
  "extensionNamespace": "",
  "fullName": "3D Colliders",
  "helpPath": "",
  "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLXRleHR1cmUtYm94IiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTIwIDJINEMyLjkgMiAyIDIuOSAyIDRWMjBDMiAyMS4xMSAyLjkgMjIgNCAyMkgyMEMyMS4xMSAyMiAyMiAyMS4xMSAyMiAyMFY0QzIyIDIuOSAyMS4xMSAyIDIwIDJNNCA2TDYgNEgxMC45TDQgMTAuOVY2TTQgMTMuN0wxMy43IDRIMTguNkw0IDE4LjZWMTMuN00yMCAxOEwxOCAyMEgxMy4xTDIwIDEzLjFWMThNMjAgMTAuM0wxMC4zIDIwSDUuNEwyMCA1LjRWMTAuM1oiIC8+PC9zdmc+",
  "name": "Colliders3D",
  "previewIconUrl": "https://asset-resources.gdevelop.io/public-resources/Icons/139be139c5bab3fc904431672eb895afb5e50bd20fb3b96b62be3318be8dee1d_texture-box.svg",
  "shortDescription": "Creating colliders and handling their collisions",
  "version": "0.0.1",
  "description": "",
  "tags": [
    "3D"
  ],
  "authorIds": [
    "l2OaORwcgyX7y4HQY2dHPmdTuDj2"
  ],
  "dependencies": [],
  "eventsFunctions": [
    {
      "fullName": "",
      "functionType": "Action",
      "name": "onFirstSceneLoaded",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "runtimeScene._3DphysicsExt = {};",
            "runtimeScene._3DphysicsExt.box = new Map();",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [],
      "objectGroups": []
    },
    {
      "description": "\nCreate an animated collider attached to a bone.",
      "fullName": "Create an animated collider",
      "functionType": "Action",
      "group": "Colliders create",
      "name": "CreateBoneBoxCollider",
      "sentence": "Create an animated collider _PARAM3_ _PARAM1_ Bone: _PARAM2_, Offset -  X: _PARAM4_, Y: _PARAM5_, Z: _PARAM6_, Width: _PARAM7_, Height: _PARAM8_, Depth: _PARAM9_, Rotation - RotX: _PARAM10_, RotY: _PARAM11_, RotZ: _PARAM12_, Color: _PARAM13_, Visible: _PARAM14_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!objects[0].colliders) {",
            "    objects[0].colliders = {};",
            "}",
            "let skeleton",
            "objects[0].get3DRendererObject().traverse((node) => {",
            "    if (node instanceof THREE.SkinnedMesh) {",
            "        // Если найден объект типа SkinnedMesh (содержащий скелетную анимацию),",
            "        // сохраняем его скелет",
            "        skeleton = node.skeleton;",
            "        // Можно выйти из цикла, если нужен только первый найденный скелет",
            "        return;",
            "    }",
            "});",
            " ",
            "const coliderIdentifier = eventsFunctionContext.getArgument(\"Identifier\");",
            "",
            "if (objects[0].colliders && objects[0].colliders[coliderIdentifier]) {",
            "    console.log(\"Collider with the specified identifier already exists for objects[0].\");",
            "} else {",
            "    ",
            "    const width = eventsFunctionContext.getArgument(\"Width\");",
            "    const height = eventsFunctionContext.getArgument(\"Height\");",
            "    const depth = eventsFunctionContext.getArgument(\"Depth\");",
            "    const geometry = new THREE.BoxGeometry(width, height, depth);",
            "    const bone = skeleton.getBoneByName(eventsFunctionContext.getArgument(\"Bone\"));",
            "",
            "    const rgbColorGD = gdjs.rgbOrHexToRGBColor(eventsFunctionContext.getArgument(\"Color\"));",
            "    const rgbColor = new THREE.Color(\"rgb(\" + rgbColorGD[0] + \", \" + rgbColorGD[1] + \", \" + rgbColorGD[2] + \")\")",
            "",
            "    const vis = eventsFunctionContext.getArgument(\"Visible\");",
            "",
            "    const material = new THREE.MeshBasicMaterial({ ",
            "        color: rgbColor, ",
            "        wireframe: true,",
            "        visible: vis // Включение режима проволочной сетки",
            "    });",
            "    const box = new THREE.Mesh(geometry, material);",
            "    ",
            "    ",
            "    box.position.set(",
            "        objects[0].getX() + eventsFunctionContext.getArgument(\"X\"),",
            "        objects[0].getY() + eventsFunctionContext.getArgument(\"Y\"),",
            "        objects[0].getZ() + eventsFunctionContext.getArgument(\"Z\")",
            "    );",
            "",
            "    box.rotation.set(",
            "        eventsFunctionContext.getArgument(\"Rotation_X\"),",
            "        eventsFunctionContext.getArgument(\"Rotation_Y\"),",
            "        eventsFunctionContext.getArgument(\"Rotation_Z\")",
            "    );",
            "",
            "   const scene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "   scene.add(box);",
            "",
            "    const newCollider = {",
            "        box: box,",
            "        type: 1",
            "    };",
            "",
            "   ",
            "    objects[0].colliders[coliderIdentifier] = newCollider;",
            "    bone.attach(box);",
            "",
            "",
            "    console.log(\"New collider added for \"+objects[0]);",
            "}",
            "",
            "",
            ""
          ],
          "parameterObjects": "Object",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object",
          "name": "Object",
          "supplementaryInformation": "Scene3D::Model3DObject",
          "type": "objectList"
        },
        {
          "description": "Bone name (letters A-Z, digits 0-9 only)",
          "name": "Bone",
          "type": "string"
        },
        {
          "description": "Identifier",
          "name": "Identifier",
          "type": "string"
        },
        {
          "description": "X offset (attached to object point)",
          "name": "X",
          "type": "expression"
        },
        {
          "description": "Y offset (attached to object point)",
          "name": "Y",
          "type": "expression"
        },
        {
          "description": "Z offset (attached to object point)",
          "name": "Z",
          "type": "expression"
        },
        {
          "description": "Width",
          "name": "Width",
          "type": "expression"
        },
        {
          "description": "Height",
          "name": "Height",
          "type": "expression"
        },
        {
          "description": "Depth",
          "name": "Depth",
          "type": "expression"
        },
        {
          "description": "Rotation X",
          "name": "Rotation_X",
          "type": "expression"
        },
        {
          "description": "Rotation Y",
          "name": "Rotation_Y",
          "type": "expression"
        },
        {
          "description": "Rotation Z",
          "name": "Rotation_Z",
          "type": "expression"
        },
        {
          "description": "Color",
          "name": "Color",
          "type": "color"
        },
        {
          "defaultValue": "True",
          "description": "Visible",
          "name": "Visible",
          "optional": true,
          "type": "trueorfalse"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Create an static collider attached to an object.",
      "fullName": "Create static collider",
      "functionType": "Action",
      "group": "Collider create",
      "name": "CreateBoxCollider",
      "sentence": "Create collider _PARAM2_ _PARAM1_, Offset -  X: _PARAM3_, Y: _PARAM4_, Z: _PARAM5_, Width: _PARAM6_, Height: _PARAM7_, Depth: _PARAM8_, Rotation - RotX: _PARAM9_, RotY: _PARAM10_, RotZ: _PARAM11_, Color: _PARAM12_, Visible: _PARAM13_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!objects[0].colliders) {",
            "    objects[0].colliders = {};",
            "}",
            "const coliderIdentifier = eventsFunctionContext.getArgument(\"Identifier\");",
            "",
            "if (objects[0].colliders && objects[0].colliders[coliderIdentifier]) {",
            "    console.log(\"Collider with the specified identifier already exists for objects[0].\");",
            "} else {",
            "    ",
            "    const width = eventsFunctionContext.getArgument(\"Width\");",
            "    const height = eventsFunctionContext.getArgument(\"Height\");",
            "    const depth = eventsFunctionContext.getArgument(\"Depth\");",
            "    const geometry = new THREE.BoxGeometry(width, height, depth);",
            "",
            "    const rgbColorGD = gdjs.rgbOrHexToRGBColor(eventsFunctionContext.getArgument(\"Color\"));",
            "    const rgbColor = new THREE.Color(\"rgb(\" + rgbColorGD[0] + \", \" + rgbColorGD[1] + \", \" + rgbColorGD[2] + \")\")",
            "",
            "    const vis = eventsFunctionContext.getArgument(\"Visible\");",
            "",
            "    const material = new THREE.MeshBasicMaterial({ ",
            "        color: rgbColor, ",
            "        wireframe: true,",
            "        visible: vis // Включение режима проволочной сетки",
            "    });",
            "    const box = new THREE.Mesh(geometry, material);",
            "    ",
            "    ",
            "    box.position.set(",
            "        objects[0].getX() + eventsFunctionContext.getArgument(\"X\"),",
            "        objects[0].getY() + eventsFunctionContext.getArgument(\"Y\"),",
            "        objects[0].getZ() + eventsFunctionContext.getArgument(\"Z\")",
            "    );",
            "",
            "    box.rotation.set(",
            "        eventsFunctionContext.getArgument(\"Rotation_X\"),",
            "        eventsFunctionContext.getArgument(\"Rotation_Y\"),",
            "        eventsFunctionContext.getArgument(\"Rotation_Z\")",
            "    );",
            "",
            "   const scene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "   scene.add(box);",
            "",
            "    const newCollider = {",
            "        box: box,",
            "        type: 1",
            "    };",
            "",
            "   ",
            "    objects[0].colliders[coliderIdentifier] = newCollider;",
            "    objects[0].get3DRendererObject().attach(box);",
            "",
            "",
            "    console.log(\"New collider added for \"+objects[0]);",
            "}",
            "",
            "",
            ""
          ],
          "parameterObjects": "Object",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "3D Object",
          "name": "Object",
          "supplementaryInformation": "Scene3D::Model3DObject",
          "type": "objectList"
        },
        {
          "description": "Identifier",
          "name": "Identifier",
          "type": "string"
        },
        {
          "description": "X offset (attached to object point)",
          "name": "X",
          "type": "expression"
        },
        {
          "description": "Y offset (attached to object point)",
          "name": "Y",
          "type": "expression"
        },
        {
          "description": "Z offset (attached to object point)",
          "name": "Z",
          "type": "expression"
        },
        {
          "description": "Width",
          "name": "Width",
          "type": "expression"
        },
        {
          "description": "Height",
          "name": "Height",
          "type": "expression"
        },
        {
          "description": "Depth",
          "name": "Depth",
          "type": "expression"
        },
        {
          "description": "Rotation X",
          "name": "Rotation_X",
          "type": "expression"
        },
        {
          "description": "Rotation Y",
          "name": "Rotation_Y",
          "type": "expression"
        },
        {
          "description": "Rotation Z",
          "name": "Rotation_Z",
          "type": "expression"
        },
        {
          "description": "Color",
          "name": "Color",
          "type": "color"
        },
        {
          "defaultValue": "True",
          "description": "Visible",
          "name": "Visible",
          "optional": true,
          "type": "trueorfalse"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Set collider offset",
      "fullName": "Set collider offset",
      "functionType": "Action",
      "group": "Colliders options",
      "name": "SetPositions",
      "sentence": "Collider _PARAM1_ _PARAM2_ set offset X: _PARAM3_, Y: _PARAM4_, Z: _PARAM5_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const identifier = eventsFunctionContext.getArgument(\"Identifier\");",
            "",
            "if (objects[0] && objects[0].colliders && objects[0].colliders[identifier]) {",
            "    const collider = objects[0].colliders[identifier].box;",
            "",
            "    // Преобразовываем мировые координаты в локальные координаты объекта",
            "    const localPosition = collider.parent.worldToLocal(",
            "        new THREE.Vector3(",
            "            objects[0].getX() + eventsFunctionContext.getArgument(\"NewX\"),",
            "            (objects[0].getY() + eventsFunctionContext.getArgument(\"NewY\"))*-1,",
            "            objects[0].getZ() + eventsFunctionContext.getArgument(\"NewZ\")",
            "        )",
            "    );",
            "",
            "    const newX = localPosition.x ;",
            "    const newY = localPosition.y ;",
            "    const newZ = localPosition.z ;",
            "",
            "    // Устанавливаем новую позицию коллайдера",
            "    collider.position.set(newX, newY, newZ);",
            "",
            "    console.info(collider.position.y);",
            "} else {",
            "    console.error(\"Collider not found or not of type box for \" + objects[0]);",
            "}",
            ""
          ],
          "parameterObjects": "Object",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Object",
          "name": "Object",
          "supplementaryInformation": "Scene3D::Model3DObject",
          "type": "objectList"
        },
        {
          "description": "Identifier",
          "name": "Identifier",
          "type": "string"
        },
        {
          "description": "New X",
          "name": "NewX",
          "type": "expression"
        },
        {
          "description": "New Y",
          "name": "NewY",
          "type": "expression"
        },
        {
          "description": "New Z",
          "name": "NewZ",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Set collider color",
      "fullName": "Set collider color",
      "functionType": "Action",
      "group": "Colliders options",
      "name": "SetColor",
      "sentence": "Collider _PARAM1_ _PARAM2_ set color _PARAM3_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const identifier = eventsFunctionContext.getArgument(\"Identifier\");",
            "",
            "if (objects[0] && objects[0].colliders && objects[0].colliders[identifier]) {",
            "",
            "const collider = objects[0].colliders[identifier].box;",
            "",
            "const rgbColorGD = gdjs.rgbOrHexToRGBColor(eventsFunctionContext.getArgument(\"Color\"));",
            "const rgbColor = new THREE.Color(\"rgb(\" + rgbColorGD[0] + \", \" + rgbColorGD[1] + \", \" + rgbColorGD[2] + \")\")",
            "",
            "collider.material.color.set(rgbColor);",
            "",
            "   ",
            "} else {",
            "    console.error(\"Collider not found or not of type box for \" + objects[0]);",
            "}",
            ""
          ],
          "parameterObjects": "Object",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Object",
          "name": "Object",
          "supplementaryInformation": "Scene3D::Model3DObject",
          "type": "objectList"
        },
        {
          "description": "Identifier",
          "name": "Identifier",
          "type": "string"
        },
        {
          "description": "Color",
          "name": "Color",
          "type": "color"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Set collider visible",
      "fullName": "Set collider visible",
      "functionType": "Action",
      "group": "Colliders options",
      "name": "SetVisible",
      "sentence": "Collider _PARAM1_ _PARAM2_ set visible _PARAM3_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const identifier = eventsFunctionContext.getArgument(\"Identifier\");",
            "",
            "if (objects[0] && objects[0].colliders && objects[0].colliders[identifier]) {",
            "",
            "const collider = objects[0].colliders[identifier].box;",
            "",
            "const vis = eventsFunctionContext.getArgument(\"Visible\");",
            "",
            "collider.material.visible = vis;",
            "",
            "   ",
            "} else {",
            "    console.error(\"Collider not found or not of type box for \" + objects[0]);",
            "}",
            ""
          ],
          "parameterObjects": "Object",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Object",
          "name": "Object",
          "supplementaryInformation": "Scene3D::Model3DObject",
          "type": "objectList"
        },
        {
          "description": "Identifier",
          "name": "Identifier",
          "type": "string"
        },
        {
          "defaultValue": "True",
          "description": "Visible",
          "name": "Visible",
          "optional": true,
          "type": "trueorfalse"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Check collision between colliders",
      "fullName": "Colliders collision",
      "functionType": "Condition",
      "group": "Colliders collisions",
      "name": "Colliders_intersect",
      "sentence": "_PARAM2_ _PARAM1_ collided with _PARAM4_ _PARAM3_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const identifier1 = eventsFunctionContext.getArgument(\"Collider1\");",
            "const identifier2 = eventsFunctionContext.getArgument(\"Collider2\");",
            "",
            "const objects1 = objects[0];",
            "const objects2 = eventsFunctionContext.getObjects(\"Object2\");",
            "",
            "const object1 = objects1;",
            "const object2 = objects2[0];",
            "",
            "",
            "if (object1 && object1.colliders && object1.colliders[identifier1] && ",
            "object2 && object2.colliders && object2.colliders[identifier2]) {",
            "",
            "    const colider1 = object1.colliders[identifier1].box;",
            "    const colider2 = object2.colliders[identifier2].box;",
            "",
            "    // Проверяем, существуют ли оба коллайдера",
            "    if (colider1 && colider2) {",
            "        // Обновляем матрицы мировых координат для коллайдеров",
            "        colider1.updateMatrixWorld();",
            "        colider2.updateMatrixWorld();",
            "",
            "        const box1 = new THREE.Box3().setFromObject(colider1);",
            "        const box2 = new THREE.Box3().setFromObject(colider2);",
            "",
            "",
            "        // Проверяем, пересекаются ли два коллайдера",
            "        if (box1.intersectsBox(box2)) {",
            "            eventsFunctionContext.returnValue = true;",
            "        } else{",
            "",
            "        }",
            "    } else {",
            "        console.error(\"One or both colliders are missing.\");",
            "    }",
            "} else {",
            "    ",
            "}"
          ],
          "parameterObjects": "Object1",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Collider object identifier #1",
          "name": "Collider1",
          "type": "string"
        },
        {
          "description": "Object #1",
          "name": "Object1",
          "supplementaryInformation": "Scene3D::Model3DObject",
          "type": "objectList"
        },
        {
          "description": "Collider object identifier #2",
          "name": "Collider2",
          "type": "string"
        },
        {
          "description": "Object #2",
          "name": "Object2",
          "supplementaryInformation": "Scene3D::Model3DObject",
          "type": "objectList"
        }
      ],
      "objectGroups": []
    }
  ],
  "eventsBasedBehaviors": [],
  "eventsBasedObjects": []
}